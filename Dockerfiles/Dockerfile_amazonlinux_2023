FROM amazonlinux:2023

# Maintainer information
LABEL maintainer="Ilya Rokhkin"

ARG TARGETPLATFORM ## Get platform linux/amd64 linux/arm64

# Update system and install EPEL repository
RUN dnf update -y && \
    dnf install -y epel-release || echo "EPEL Release failed" && \
    dnf clean all

# Install all system packages, development tools, and DevOps tools in a single layer
RUN dnf install -y \
        bash-completion \
        bc \
        blktrace \
        crash \
        e2fsprogs \
        ethtool \
        file \
        findutils \
        gcc \
        gcc-c++ \
        gdb \
        gdb-gdbserver \
        git \
        glibc-common \
        glibc-utils \
        golang \
        hwloc \
        iotop \
        iproute \
        iputils \
        less \
        ltrace \
        mailx \
        man-db \
        nc \
        net-tools \
        numactl \
        numactl-devel \
        ostree \
        passwd \
        pciutils \
        perf \
        procps-ng \
        psmisc \
        python3-pip \
        rootfiles \
        screen \
        strace \
        sudo \
        sysstat \
        systemtap \
        systemtap-client \
        tar \
        tcpdump \
        tmux \
        traceroute \
        unzip \
        vim-enhanced \
        vim-minimal \
        wget \
        which \
        xauth \
        yum-utils \
        dos2unix \
        jq \
        htop \
        tree \
        hostname \
        bind-utils \
        ca-certificates \
        nano \
        vim \
        make \
        openssl-devel \
        python3-devel \
        libffi-devel \
        nodejs \
        awscli \
        docker \
        docker-selinux \
        zsh \
        # Install certificates and update certificate store for Amazon Linux 2023
        ca-certificates && \ 
    update-ca-trust extract && \
    # Create symlinks for common certificate paths if they don't exist
    mkdir -p /etc/pki/tls/certs /etc/ssl/certs && \
    # Link the system CA bundle to common locations
    ln -sf /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem /etc/pki/tls/certs/ca-bundle.crt && \
    ln -sf /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem /etc/ssl/certs/ca-certificates.crt && \    
    # Clean up package cache to reduce image size
    dnf clean all && \
    rm -rf /var/cache/dnf

# Upgrade pip and install all Python modules in a single command
RUN python3 -m ensurepip --upgrade --verbose && \
    python3 -m pip install --upgrade --ignore-installed pip --verbose && \
    # Install all Python packages including AWS CLI dependencies and DevOps tools
    python3 -m pip install \
        cryptography \
        pyyaml \
        redis \
        aws-sso-util \
        awsume \
        git-remote-codecommit \
        azure-cli

# Install Homebrew
RUN git clone https://github.com/Homebrew/brew /usr/local/bin/Homebrew \
&& ln -s /usr/local/bin/Homebrew/bin/brew /usr/local/bin \
&& eval brew shellenv \
&& brew --version

# Set environment variables for pyenv
ENV PYENV_ROOT="/usr/local/pyenv"
ENV PATH="$PYENV_ROOT/bin:$PYENV_ROOT/shims:$PATH"

# Install pyenv
RUN curl https://raw.githubusercontent.com/pyenv/pyenv-installer/master/bin/pyenv-installer | bash \
    && chmod -R 777 $PYENV_ROOT

# Ensure pyenv is available system-wide
RUN echo 'export PYENV_ROOT="/usr/local/pyenv"' >> /etc/profile.d/pyenv.sh \
    && echo 'export PATH="$PYENV_ROOT/bin:$PYENV_ROOT/shims:$PATH"' >> /etc/profile.d/pyenv.sh \
    && chmod +x /etc/profile.d/pyenv.sh

# Verify pyenv installation
RUN pyenv versions

# Install Terraform from source compilation
RUN TERRAFORM_VERSION=$(curl -s https://api.github.com/repos/hashicorp/terraform/releases/latest | jq -r .tag_name | sed 's/^v//') && \
    ARCH=$(echo ${TARGETPLATFORM} | awk -F\/ '{print $2}') && \
    # Map architecture names to Terraform's naming convention
    if [ "$ARCH" = "amd64" ]; then TERRAFORM_ARCH="amd64"; elif [ "$ARCH" = "arm64" ]; then TERRAFORM_ARCH="arm64"; else TERRAFORM_ARCH="amd64"; fi && \
    echo "Installing Terraform version: ${TERRAFORM_VERSION} for architecture: ${TERRAFORM_ARCH}" && \
    # Download the latest Terraform binary
    curl -LO "https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_${TERRAFORM_ARCH}.zip" && \
    # Verify the download and extract
    unzip "terraform_${TERRAFORM_VERSION}_linux_${TERRAFORM_ARCH}.zip" && \
    # Move to system binary directory and make executable
    chmod +x terraform && \
    mv terraform /usr/local/bin/ && \
    # Clean up downloaded files
    rm -f "terraform_${TERRAFORM_VERSION}_linux_${TERRAFORM_ARCH}.zip" && \
    # Verify installation
    terraform version

# Set Go environment variables
ENV PATH="/usr/local/go/bin:${PATH}"

# Install Kubectl with repository configuration
RUN KUBECTL_VERSION=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt) && \
    BASE_VERSION=$(echo $KUBECTL_VERSION | awk -F. '{print $1"."$2}') && \
    echo "[kubernetes]" | tee /etc/yum.repos.d/kubernetes.repo && \
    echo "name=Kubernetes" | tee -a /etc/yum.repos.d/kubernetes.repo && \
    echo "baseurl=https://pkgs.k8s.io/core:/stable:/${BASE_VERSION}/rpm/" | tee -a /etc/yum.repos.d/kubernetes.repo && \
    echo "enabled=1" | tee -a /etc/yum.repos.d/kubernetes.repo && \
    echo "gpgcheck=1" | tee -a /etc/yum.repos.d/kubernetes.repo && \
    echo "gpgkey=https://pkgs.k8s.io/core:/stable:/${BASE_VERSION}/rpm/repodata/repomd.xml.key" | tee -a /etc/yum.repos.d/kubernetes.repo

RUN cat /etc/yum.repos.d/kubernetes.repo

# Install kubectl using the defined version
RUN dnf install -y kubectl && \
    dnf clean all

# Install Helm
# Download and install the latest Helm version
RUN export VERIFY_CHECKSUM=false && curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 && \
    chmod +x get_helm.sh && \
    ./get_helm.sh && \
    rm get_helm.sh

# Install Azure CLI
RUN python3 -m pip install azure-cli

# Get latest version from GitHub API
RUN VERSION=$(curl -s https://api.github.com/repos/helmfile/helmfile/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/' | sed 's/^v//') &&\
    ARCH=$(echo ${TARGETPLATFORM} | sed 's/\//_/g') && \
    curl -LO "https://github.com/helmfile/helmfile/releases/download/v${VERSION}/helmfile_${VERSION}_${ARCH}.tar.gz" &&\
    tar -xzf "helmfile_${VERSION}_${ARCH}.tar.gz" && \
    chmod +x helmfile && \
    mv helmfile /usr/local/bin/

# Install eksctl
RUN EKSCTL_LATEST_VERSION=$(curl --silent "https://api.github.com/repositories/134539560/releases/latest" | jq -r .tag_name) && ARCH=$(echo ${TARGETPLATFORM} | awk -F\/ '{print $2}') && curl -Lo eksctl_Linux_${ARCH}.tar.gz https://github.com/eksctl-io/eksctl/releases/download/${EKSCTL_LATEST_VERSION}/eksctl_Linux_${ARCH}.tar.gz && tar -xzf eksctl_Linux_${ARCH}.tar.gz && rm eksctl_Linux_${ARCH}.tar.gz && mv eksctl /usr/local/bin && chmod +x /usr/local/bin/eksctl

RUN TERRAGRUNT_VERSION=$(curl -s https://api.github.com/repos/gruntwork-io/terragrunt/releases/latest | grep 'tag_name' | cut -d\" -f4 | tr -d '\n') && \
    ARCH=$(echo ${TARGETPLATFORM} | sed 's/\//_/g') && \
    echo "Terragrunt version: ${TERRAGRUNT_VERSION}" && \
    echo "Architecture: ${ARCH}" && \
    curl -L "https://github.com/gruntwork-io/terragrunt/releases/download/${TERRAGRUNT_VERSION}/terragrunt_${ARCH}" -o /usr/local/bin/terragrunt && \
    chmod +x /usr/local/bin/terragrunt

# Install SOPS (Secrets OPerationS) for encrypting/decrypting files
RUN SOPS_VERSION=$(curl -s https://api.github.com/repos/getsops/sops/releases/latest | jq -r .tag_name | sed 's/^v//') && \
    ARCH=$(echo ${TARGETPLATFORM} | awk -F\/ '{print $2}') && \
    echo "Installing SOPS version: ${SOPS_VERSION} for architecture: ${ARCH}" && \
    # Download the latest SOPS binary
    curl -LO "https://github.com/getsops/sops/releases/download/v${SOPS_VERSION}/sops-v${SOPS_VERSION}.linux.${ARCH}" && \
    # Move to system binary directory and make executable
    mv "sops-v${SOPS_VERSION}.linux.${ARCH}" /usr/local/bin/sops && \
    chmod +x /usr/local/bin/sops && \
    # Verify installation
    sops --version

# Install regctl for container registry management and image manipulation
RUN REGCTL_VERSION=$(curl -s https://api.github.com/repos/regclient/regclient/releases/latest | jq -r .tag_name | sed 's/^v//') && \
    ARCH=$(echo ${TARGETPLATFORM} | awk -F\/ '{print $2}') && \
    echo "Installing regctl version: ${REGCTL_VERSION} for architecture: ${ARCH}" && \
    # Download the latest regctl binary for the target architecture
    curl -LO "https://github.com/regclient/regclient/releases/download/v${REGCTL_VERSION}/regctl-linux-${ARCH}" && \
    # Move to system binary directory and make executable
    mv "regctl-linux-${ARCH}" /usr/local/bin/regctl && \
    chmod +x /usr/local/bin/regctl && \
    # Verify installation by checking version
    regctl version

# Install crane for copying container images between registries
# Also install yq YAML processor tool using Go with dynamic major version detection
RUN go install github.com/google/go-containerregistry/cmd/crane@latest && \
    # Fetch the latest yq version from GitHub API and extract major version
    LATEST=$(curl -s https://api.github.com/repos/mikefarah/yq/releases/latest | grep -o '"tag_name": "v[^"]*"' | cut -d'"' -f4) && \
    MAJOR=$(echo $LATEST | cut -d. -f1) && \
    echo "Installing yq version: ${LATEST} using major version path: ${MAJOR}" && \
    # Install yq using the dynamically determined major version instead of hardcoded v4
    go install github.com/mikefarah/yq/${MAJOR}@${LATEST} && \
    # Copy Go-installed binaries to system PATH for global access
    cp /root/go/bin/* /usr/local/bin/ 2>/dev/null || true && \
    # Clean up Go build cache and module cache to reduce image size
    go clean -cache -modcache -testcache && \
    # Remove Go temporary files and build artifacts
    rm -rf /tmp/go-* /root/.cache/go-build /root/go/pkg/mod/cache

# Install kustomize for Kubernetes configuration management
RUN KUSTOMIZE_VERSION=$(curl -s https://api.github.com/repos/kubernetes-sigs/kustomize/releases/latest | jq -r .tag_name | sed 's/kustomize\///') && \
    ARCH=$(echo ${TARGETPLATFORM} | awk -F\/ '{print $2}') && \
    echo "Installing kustomize version: ${KUSTOMIZE_VERSION} for architecture: ${ARCH}" && \
    # Download the latest kustomize binary for the target architecture
    curl -LO "https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2F${KUSTOMIZE_VERSION}/kustomize_${KUSTOMIZE_VERSION}_linux_${ARCH}.tar.gz" && \
    # Extract the binary
    tar -xzf "kustomize_${KUSTOMIZE_VERSION}_linux_${ARCH}.tar.gz" && \
    # Move to system binary directory and make executable
    chmod +x kustomize && \
    mv kustomize /usr/local/bin/ && \
    # Clean up downloaded files
    rm -f "kustomize_${KUSTOMIZE_VERSION}_linux_${ARCH}.tar.gz" && \
    # Verify installation
    kustomize version

# Switch to root user
USER root

# Default entrypoint
ENTRYPOINT [ "/bin/zsh" ]
